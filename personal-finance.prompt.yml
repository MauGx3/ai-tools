messages:
  - role: system
    content: >-
      ---

      applyTo: '**/*.py, **/*.ipynb'

      ---

      ALWAYS remember The Zen of Python.


      # Coding Style Guidelines/Conventions


      You MUST follow all of those conventions when writing Python code. Any
      code that violates these rules should be rewritten immediately:


      * Follow PEP 8 standards ALWAYS, above any of the following conventions

      * When in doubt, follow the [Google Code Style for
      Python](https://google.github.io/styleguide/pyguide.html)

      * Documentation, on the other hand, must follow the Google Code Style for
      Python guidelines.

      * Every module must have a docstring, functions must have docstrings when
      in line with the Google Code Style for Python section 3.8.3 rules.

      * Features from recent Python releases (up to our project version) should
      be used instead of older code (e.g. as of 3.14, t-strings, incremental
      garbage collection, modern type parameter syntax etc).

      * Write modular code whenever possible.

      * Use meaningful method, variable and parameter names, and always annotate
      the data types of parameters and return values.

      * The documentation structure must be
      [Sphinx](https://www.sphinx-doc.org/en/master/) compatible:

      * For functions which implement mathematical/scientific concepts, add the
      actual mathematical formula as comment or to the docstrings.

      * Code performance must be followed by using the [Python Speed
      guidelines](https://wiki.python.org/moin/PythonSpeed)

      * Leverage existing libraries: Before writing your own solution, check if
      there's an existing library you can use.


      # Specific Instructions


      * Donâ€™t introduce new dependencies (library imports) when the desired
      functionality is already covered by existing dependencies.

      * Use the built-in type hinting when possible, avoid using the `typing`
      module unless necessary for backward compatibility.

      * Avoid using magic numbers, prefer using named constants.

      * Always use lazy % string logging.

      * Don't use bare exceptions.

      * Use namedtuples when: You need immutable data with named fields for
      better readability (replacing tuples with unclear indices, function
      returns, or lightweight data containers).
        Avoid namedtuples when: You need mutable data, dynamic fields, complex behavior, or performance-critical dynamic creation (use classes, dataclasses, or dicts instead).
      * No context-dependent return types! Also: Avoid None as return type,
      rather raise an Exception instead.

      * Be generous with defining Exception classes.

      * Imports should be grouped in the following order, and always at the top
      of the file:
        1. Standard library imports (such as re, math, datetime, cf. here )
        2. Related third party imports (such as numpy)
        3. Local application/library specific imports (such as mycode.mymodule.base)
      * You should put a blank line between each group of imports.

      * Avoid circular importing.

      * Use Factory Method when: You have complex if/elif/else logic to create
      different objects with a common interface, or need to support multiple
      implementations of the same feature without modifying existing code.
        Avoid Factory Method when: You only have one concrete implementation, the creation logic is simple and unlikely to change, or the overhead of the pattern outweighs its benefits for your use case.

      # Edge Cases and Testing


      * Always include test cases for critical paths of the application.

      * Account for common edge cases like empty inputs, invalid data types, and
      large datasets.

      * Include comments for edge cases and the expected behavior in those
      cases.

      * Write unit tests for functions and document them with docstrings
      explaining the test cases.


      # Tools and Utilities


      The preferences listed here are not definitive: if the alternative needs
      to be used for compatibility, do it


      * `uv` is preferred over `pip`, and any virtual environment must be
      created using `uv venv`

      * `ruff` must be used as the formatter and all code must follow [ruff's
      default rules](https://docs.astral.sh/ruff/rules)

      * `polars` is preferred over `pandas`

      * `pytest` is the preferred test framework.

      * `loguru` is preferred over the built-in logging library


      THERE IS NO NEED TO MENTION THAT YOU HAVE FOLLOWED ANY OF THIS IN YOU
      RESPONSE, ONLY IF IT IS IMPORTANT TO UNDERSTAND THE ENTIRE JOB!
  - role: user
    content: >-
      # Personal Finance Project default prompt


      ## Prompt Identification


      - **Name**: Personal Finance Project default prompt

      - **Version**: 0.5

      - **Created By**: MauGx3

      - **Last Modified**: 2025-09-12

      - **Category**: Web and desktop app


      ## Purpose and Goals


      - **Primary Goal**: Create a basic web and desktop app using Python,
      Django and Docker, primarily focused on functionality, that contains the
      features stated on the SCAFF structure below.

      - **Use Cases**: web development, software development, finance, investing

      - **Expected Output**: A simple GUI that has functional modules to be
      further developed and debugged.


      ## Technical Configuration


      - **Target Model**: GitHub Copilot

      - **Parameters**:
        - Temperature: 0.5
        - Token Limit: 4000 tokens
        - Top-K: N/A
        - Top-P: N/A

      ## S.C.A.F.F. Structure


      ### Situation


      This code uses Django as the web framework. The code depends on many
      dependencies, but the finance packages are essential, such as `yfinance`,
      `stockdex`, etc that need to work properly and have fallbacks to guarantee
      best functionality for the app. The complete list of packages to be used
      in the project can be found at /.github/copilot-instructions.md


      ### Challenge


      Create a complete personal finance/investing platform complete with
      portfolio tracking, asset data visualization, charts, quantitative
      analysis, backtesting etc. The app should be available as a deployment on
      Render for easier development with automatic container creation.


      ### Audience


      Keep the code accessible to junior developers where possible, but don't
      let it be a constraint for making better code if a more complex approach
      would lead to better performance, security etc. Use comments where needed
      to explain code for a junior dev, in that case.


      ### Format


      - **Code Style**: Follow Pythonic foundations.

      - **Documentation**: Use Google documentation guidelines for Python code.

      - **Project Template**: Started using the [cookiecutter-django] template.

      - **Formatter**: Use `ruff` for code formatting.

      This code will be mostly deployed as a Docker container, so there should
      be a focus on maintaining security and performance for a Docker app. For
      my personal use, I will run the app on a QNAP NAS running QTS 5. A large
      amount of data will be expected to be used as the app develops and the
      user collects more data, so consider best practices for following Big Data
      performance.

      - **Testing**: Use `pytest` for tests.

      - **Local Development**: Use `docker-compose` for local development and
      testing.

      - **Version Control**: Use `git` for version control.

      - **Branching Strategy**: Use `main` as production-ready, `dev` as the
      main development branch, and feature branches for specific features or bug
      fixes.

      - **Coding Style**: Follow the "Easier to ask for forgiveness than
      permission" (EAFP) style unless "Look before you leap" (LBYL) is assessed
      to be a better option for a particular block of code.


      ### Foundations


      This code will be mostly deployed as a Docker container, so there should
      be a focus on maintaining security and performance for a Docker app. For
      my personal use, I will run the app on a QNAP NAS running QTS 5. A large
      amount of data will be expected to be used as the app develops and the
      user collects more data, so consider best practices for following Big Data
      performance.


      ## Usage Guidelines


      - **For Security-Critical Components**:

        - Set temperature: 0.0-0.2
        - Include explicit security requirements
        - Request detailed documentation of security measures
      - **For Performance-Sensitive Components**:

        - Specify performance constraints
        - Request optimization techniques
        - Require complexity analysis
      - **For UI Components**:

        - Include accessibility requirements
        - Specify responsive design needs
        - Reference design system patterns

      ## Effectiveness Metrics


      - **Success Rate**: 85% usable on first attempt

      - **Iteration Count**: Usually 3 to 5 iterations

      - **Issues Found**: None so far

      - **Time Savings**: Approximately 5 to 7 hours per implementation


      ## Documentation


      - **Related Components**: N/A

      - **Security Review**: Codebase verified by Snyk.io, Deepsource and
      automated code reviews by Copilot

      - **Notes and Insights**: This prompt was created based on the Vibe Coding
      Framework and follows the S.C.A.F.F. Prompt Structure. Refer to this docs
      regarding AI coding:
      [https://docs.vibe-coding-framework.com/](https://docs.vibe-coding-framework.com/)

      - **Improvement History**:
        - 0.1: initial prompt
        - 0.2: added more details to the SCAFF structure
        - 0.3: added more packages to Situation and added Render info
        - 0.4: added EAFP info
        - 0.5: removed package info that is now contained at /.github/copilot-instructions.md
model: openai/gpt-5-mini
